// Code generated by protoc-gen-echo. DO NOT EDIT.
// versions:
// - protoc-gen-echo v1.0.0
// - protoc          v4.25.1
// source: helloworld.proto

package __

import (
	"io/ioutil"
	"bytes"
	"context"
	"encoding/json"
	"net/http"
	"net/url"
	"fmt"

	"github.com/luojinbo008/gost/cmd/runtime"
)

type HelloworldHTTPClient interface {
	SayHello(ctx context.Context, req *HelloRequest) (rsp *HelloReply, err error)
}

type HelloworldHTTPClientImpl struct {
	cc   *http.Client
	host string
}

func NewHelloworldHTTPClient(client *http.Client, host string) HelloworldHTTPClient {
	return &HelloworldHTTPClientImpl{client, host}
}

// Reference ...
func (c *HelloworldHTTPClientImpl) Reference() string {
	return "HelloworldHTTPClientImpl"
}

func (c *HelloworldHTTPClientImpl) SayHello(ctx context.Context, in *HelloRequest) (*HelloReply, error) {
	var out HelloReply
	pattern := runtime.Path(fmt.Sprintf("%s%s", c.host, "/helloworld/:name"))

	res, err := c.Call(ctx, "GET", pattern, in)
	if err != nil {
		return &out, err
	}

	err = json.Unmarshal(res, &out)
	if err != nil {
		return &out, err
	}
	return &out, err
}

func (c *HelloworldHTTPClientImpl) GetGostStub(cc *http.Client, host string) HelloworldHTTPClient {
	return NewHelloworldHTTPClient(cc, host)
}

func (c *HelloworldHTTPClientImpl) Call(ctx context.Context, method string, pattern runtime.Path, in interface{}) ([]byte, error) {
	body, err := runtime.Values(pattern, in)
	if err != nil {
		return nil, err
	}

	u, err := url.Parse(body.GetPath())
	if err != nil {
		return nil, err
	}

	if body.GetQuery() != nil {
		query := u.Query()
		u.RawQuery = query.Encode()
	}

	reqURL := u.String()
	var paramBody []byte
	paramBody, err = json.Marshal(in)
	if err != nil {
		return nil, err
	}

	// Request instant
	req, err := http.NewRequestWithContext(ctx, method, reqURL, bytes.NewBuffer(paramBody))
	if err != nil {
		return nil, err
	}

	// headers
	req.Header = body.GetHeader()
	req.Header.Add("Content-type", "application/json")

	// do request
	resp, err := c.cc.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	res, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return res, nil
}
